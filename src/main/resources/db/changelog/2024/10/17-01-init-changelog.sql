DO
$$
   DECLARE
description TEXT;
BEGIN
   description
:=
'1. Создать программу master.c которая выводит "hello world" на экран:
    a. Получить исполняемый файл;
    b. Посмотреть зависимости (ldd);
    c. Запустить.
2. Написать статическую библиотеку с функцией hello_from_static_lib() и использовать ее в master.c:
    a. Посмотреть исполняемый файл на предмет того, будет ли функция hello_from_static_lib() unresolved. Почему?
    b. Где находится код этой функции?
3. Написать динамическую библиотеку с функцией hello_from_dynamic_lib() и использовать ее с master.c:
    a. Посмотреть состояние функции hello_from_dynamic_lib в получившемся исполняемом файле.
    b. Объяснить увиденное.
4. Система плагинов:
    a. Создать папку contrib для плагинов;
    b. Создать папку plugin для вашего первого плагина. В данной папке написать код для динамической библиотеки ' ||
        'plugin.so (он должен находиться в top_build_directory/contrib/plugin и при сборке должен быть скопирован в ' ||
        'top_build_directory/install/contrib). В библиотеке должна быть определена функция void init(void),' ||
        ' выводящая строку "init successfully" на экран;
    c. Загрузить ее в master.c с помощью dlopen(3) и dlsym(3);
    d. Объяснить, что происходит;
    e. Сделать файл include/master.h, определить в нём указатель на функцию с именем Hook (void (*Hook)(void)), ' ||
        'объявить два extern указателя типа Hook start_hook() и end_hook(), и определить их в master.c как NULL;
    f. В функции init написать функцию then_start(), выводящую строку "hello from then_start()" на экран и сохранить' ||
        ' в start_hook указатель на неё;
    g. В master.c попытаться вызвать start_hook и объяснить, почему это не сработало (см. -export-dynamic gcc flag);
    h. Привести код в рабочее состояние (должен произойти вызов init, после чего из master.c должен быть сделан ' ||
        'вызов переопределённого хука start_hook() и выведена строка "hello from then_start()");
    i. Сделать так, чтобы вызов end_hook выводил строку "init end" по аналогии со start_hook."';

INSERT INTO laboratory (name, description, semester_number, deadline, is_hidden)
VALUES ('Laboratory 1. Compile & assembling & launch',
        description,
        4,
        '2024-05-06 23:59:59Z',
        false);

END $$;

DO
$$
   DECLARE
description TEXT;
BEGIN
   description
:=
 '1. Создать конфиг (статическая библиотека):
    a. Поддерживаемые типы: long, double, string (одиночные и массивы).
    b. Путь к файлу конфигурации указывается при запуске после флага -c. Если флаг не указан, то программа ищет ' ||
        'файл конфигурации в текущей директории. Если файл не был найден, то устанавливаются стандартные значения ' ||
        'конфигурации.
    c. Придумайте систему хранения конфигурации программы, не использующую глобальные переменные ' ||
        '(Grand Unified Configuration).

2. Создать логгер (динамическая библиотека):
    a. Лог должен иметь сигнатуру int elog(elevel lvl, char * format, ...), где elevel - enum {debug, info, ' ||
        'warn, error, fatal}, а также elog - вариадическая функция.
    b. Лог должен содержать уровень сообщения, строки и само сообщение.
    c. Путь до директории, в которой будут находиться лог файлы, может быть указан при запуске через флаг -l ' ||
        '(тогда другие варианты не рассматриваются), либо в файле конфигурации через ключ log_dir. Если ничего не ' ||
        'указано, то в текущей директории будет создана директория logs, и в ней будут лежать лог файлы.
    d. В файле конфигурации можно указать ограничение на размер лог файла (log_file_size_limit), а также свойство' ||
        ' цикличности (log_loop). Если лог файл цикличен и его размер ограничен, то при превышении ограничения ' ||
        'файл будет перезаписываться с начала (сделать метку begin для определения границ лог файла).

3. Работа с символьными ссылками:
    a. Напишите новую версию логгера, в которой в лог кроме уровня сообщения и сообщения будут выводиться: файл, ' ||
        'номер строки и время. Реализуйте его самостоятельно через системный вызов и используя time.h. Сравните ' ||
        'время работы своей и стандартной реализации, объясните результат.
    b. Сохраните обе версии логгера.
    c. Не изменяя команд компиляции программы, слинкуйте с основным блоком новую версию логгера вместо ' ||
        'старой (используйте символьные ссылки).

4. Работа с жёсткими ссылками:
    a. Напишите плагин, который будет копировать лог файлы в резервную директорию, при этом не используя read и write.';

INSERT INTO laboratory (name, description, semester_number, deadline, is_hidden)
VALUES ('Laboratory 2. Files',
        description,
        4,
        '2025-05-06 23:59:59Z',
        false);

END $$;

DO
$$
   DECLARE
description TEXT;
BEGIN
   description
:=
  '1. Написать собственный аллокатор:
    a. Присоедините анонимный регион (mmap(2));
    b. Реализуйте функцию my_malloc(), которая:
        i. Принимает размер памяти в байтах;
        ii. Резервирует буфер запрошенного размера и возвращает указатель на его начало;
        iii. При недостатке памяти возвращает NULL.
    c. Реализуйте функцию my_free(), которая:
        i. Принимает указатель на буфер, возвращенный ранее функцией my_malloc();
        ii. Помечает буфер свободным.
    d. Рекомендация: Для отладки можно присоединить регион, связанный с файлом. Это позволит наблюдать за ' ||
        'состоянием вашей кучи при выделении и освобождении памяти.

2. Над этим аллокатором реализовать свой кеш:
    a. Реализовать функцию int construct_cache(), которая:
        i. Запрашивает у аллокатора определённый объём памяти (задаётся в конфиге в параметре memory_for_cache);
        ii. Размерность данных из memory_for_cache задаётся в параметре конфига unit_memory (возможные значения: ' ||
        '"b", "Kb", "Mb", "Gb");
        iii. Возвращает 0, если успех, не 0, если неуспех.
    b. Реализовать функцию int cache_write(const char *key, const char *value, const size_t value_size, const ' ||
        'unsigned ttl), которая:
        i. Записывает в кэш данные из value по ключу key;
        ii. Замечание: Параметр ttl отвечает за время жизни сохранённых в кэше данных. Его реализация опциональна, ' ||
        'но в сигнатуре он обязателен;
        iii. Возвращает 0, если успех, не 0, если неуспех.
    c. Реализовать void *cache_read(const char *key), которая:
        i. Читает данные из кэша по заданному ключу;
        ii. Возвращает указатель на кэш в случае успеха и NULL в случае неудачи.
    d. Реализовать void destruct_cache(void), которая деконструирует кэш.
3. Протестируйте кэш.
    a. Закэшируйте файл /proc/self/maps, а после выведите его в лог.';

INSERT INTO laboratory (name, description, semester_number, deadline, is_hidden)
VALUES ('Laboratory 3. Address space',
        description,
        4,
        '2025-05-06 23:59:59Z',
        false);

END $$;

DO
$$
   DECLARE
description TEXT;
BEGIN
   description
:=
    '1. Написать новое расширение для вычисления синуса с помощью разложения в ряд (или что угодно, ' ||
        'что можно запустить в фоне параллельно основному процессу).
2. Вынести выполнение этой операции в отдельный процесс с помощью системного вызова clone.
3. Дочерние процессы должны не только порождаться, но и корректно завершаться (с освобождением стека и всем прочим),' ||
        ' а значит где-то надо хранить структуры, их описывающие.
4. Добавить в логгер возможность логировать сообщения сразу нескольких процессов (пока без примитивов синхронизации).';

INSERT INTO laboratory (name, description, semester_number, deadline, is_hidden)
VALUES ('Laboratory 4. Processes',
        description,
        4,
        '2025-05-06 23:59:59Z',
        false);

END $$;

DO
$$
   DECLARE
description TEXT;
BEGIN
   description
:=
    'Расширить процедуру создания дочерних процессов для расширений добавив возможность создавать' ||
    ' дополнительный процесс-трассер, который будет подключаться к дочернему процессу с помощью ptrace и ' ||
    'печатать коды системных вызовов нашего дочернего процесса. Дочерний процесс для расширения должен ' ||
    'порождать трассер, поскольку иначе без изменений в конфигурационных файлах операционной системы это ' ||
    'работать не будет. Соответственно он же отвечает за завершение этого дочернего процесса.';

INSERT INTO laboratory (name, description, semester_number, deadline, is_hidden)
VALUES ('Laboratory 5. System calls',
        description,
        4,
        '2025-05-06 23:59:59Z',
        false);

END $$;
